B tree

자녀노드의 최대갯수를 늘리기 위해서 부모노드의 key를 하나 이상 저장한다.
부모노드의 key들을 오름차순으로 정렬한다.
정렬된 순서에 따라 자녀노드의 key값의 범위가 결정된다.
> 자녀노드의 최대갯수를 결정해서 쓸 수 있다.

특징.1
M =  각 노드의 최대 자녀 노스 수 라고하면
최대 M개의 자녀를 가질 수 있는 B tree를 M차 B tree라 부른다.
M-1: 각 노드의 최대 key수
M/2의 올림: 각 노드의 최소 자녀 노드 수(root node, leaf node 제외)
M/2의 올림 -1: 각 노드의 최소 key 수 (root node 제외)

2.
internal 노드의 key수가 x개라면, 자녀 노드의 수는 언제나 x+1개다.

3.모든 leaf node는 같은 레벨에 있다
-> balanced tree 하기의 과정을 따른다.(big O(longN)
=======

B tree 삽입

1.추가는 항상 leaf node에서 한다.
2.node가 넘치면 median(가운데) key를 기준으로 좌우key들은 분할하고 가운데 key는 승진한다.

==============

B tree 삭제

삭제도 항상 leaf node에서 진행된다.
삭제 후 최소key수 보다 적어졌다면 재조정한다.
> 가령 3차 B tree인 경우에는 1.5의 올림인 2-1 =1 즉, 각 노드의 key가 1개보다 작아진다면 재조정이 이루어진다.

재조정은 하기의 과정을 거친다
1.key수가 여유있는 형제의 도움을 받는다.
2.1이 불가하다면 부모의 지원을 받고 형제와 합친다.
3.2번 이후 부모노드의 문제가 생긴다면 그 곳에서 다시 재조정을한다.

1의 자세한 경우
동생노드로부터 큰값의 key를 부모노드의 노드에 둬서 부모노드로부터 key받는다.
동생노드로부터의 key를 받을 수 없다면 불가하다면 형 노드가 작은 키값을 부모노드와 본 노드 사이에 둔 후 부모노드에 있던 자리로 이동
2의 경우
왼쪽으로 옮기 왼쪽으로 합친다.
3의 경우
부모가 root node가 아니라면 그 위치에서 부터 다시 1번부터 재조정시작
부모가 root노드이고 비었다면 부모노드 삭제 후 직전에 합쳐진 노드가 root node가 된다.

==> 어 그럼 internal node에서 데이터 삭제해야되면 어캄?
> leaf node에 있는 predecessor or successor와 데이터와 위치를 바꾼 후 삭제한다.
*predecessor 나보다 작은 데이터 중 가장 큰 데이터
**successor 나보다 큰 데이터 중 가장 작은 데이터