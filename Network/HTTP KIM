IP를 통해 클라이언트와 서버가 소통하나 팻킷전달시 TCP가 있어야 올바른 순서로 전달 가능


인터넷 프로토콜 4계층
APLLICATION SOCKET으로 전달
TRANSFER SEGMENTATION
INTERNET PACKET
INTERFACE FRAME

TCP특 (전송정보, 순서 등이 포함되어있다)
-3way handshake
-연결지향 순서보장
-데이터전달보증

3way handshake?
SYN(client) SYNACK(server) ACK(client)

*udp는 tcp와 같은 특징은 없고 포트만 있음 => 그래서 빠름


ip => host(네트워크 연결된 컴퓨터) 식별할 수 있는 번호
packet에는 송장과 같이 tcp ip 정보 20바이트와 최대1460바이트의 정보가 담길 수 있음

DNS => 알파벳으로 주소 쉽게 찾고, IP변경되고 쉽게 찾아올 수 있도록함.

===================================

URI 리소스 식별 (like 주민번호) => URL URI를 합친 것
UNIFORM 통일된 방식
RESOURCE 식별할 수 있는 모든 자
URL 리소스로케이터(자원 여깄음) == 위치는 변할 수 있음
URN 리소스네임(자원이름 이거임) =>안씀(이름은 안변함)

=====================================

HTTP는

1. Client -Server Structure
    요청과 응답의 구조를 갖는다
2. Stateless(무상태)
   서버가 클라이언트의 상태를 보존하지 않는다. (서버의 대거투입가능)

   한계: 로그인과 같은 서버에 상태유지가 필요한경우에는 곤란하다.(하지만 쿠키나 서버세션을 통해 상태를 유지한다)
   =>상태유지는 최소한으로한다

    --> 선착순이벤트를한다면 무상태의 의미성이 낮아진다. 고로 정저게이지를 하나 던져두면 그나마 낫다고한다... ㅋㅋ
3. Connectionless(비연결성)
    최소한의 자원 유지를 통한 효율적인사용

    한계: 연결 계속하려면 다시 3handshake과정의 시간 필요
    극복: 지속연결(persistent connections)을 통해 극복
4. HTTP Message
    시작 - 헤더 - 공백 - 바디 의 구조를 갖는다.

    (1) 시작라인
    requestline 요청메시지
    메서드 / 대상 HTTP버전이 기입된다. (대상 = 경로)


    statusline 응답 메시지
    버전 상태코드 상태코드의글

    (2)header
    http전송에 필요한 모든 정보

    (3)body
    실제 데이터

========================================

API를 만든다면 ~ 리소스만 식벽하면된다. 행위는 상관없음
행위는 HTTP메서드로하면됨(get post patch put delete ~)
put : 덮어쓰기 (**클라이언트가 리소스의 위치를 알고 URI를 지정) <-> post는 클라가 리소스 위치 모름

patch : 부분 변경 (내 개념에서의 수정) // patch 지원안하면 post로 수정한다.
post : 요청의 처리 (생성, 프로세스 처리 like결제에 따라 배달 및 배달완료, 메시지 게시 등)

HTTP 메서드의 속성 -

    (1)멱등(몇번을 호출해도 결과값이 같다)
     get, put, delete // post는 멱등하지 않다.=> 가령 결제가 2번될 수 있음.
    (외부에의한 변경은 고려하지 않는다)

    (2)캐시 가능
    보통 get만 캐시로 이용함.

    (3)get 안전

=====================================

Clien => Server data transfer
1. query parameter with Get
2. messagebody with Post,Put,Patch

post 신규자원등록시 클라이언트는 등록될 리소스uri를 모른다 (서버가 관리하는 리소스저장소 collection)
put 신규자원등록시 클라이언트는 등록될 리소스uri를 지정해야한다. (클라이언트가 관리하는 리소스저장소 store라고함)

HTML Form만 사용한다면 Get,Post만 사용하는제약 존재. => 동사적리소스경로를 사용.(control URI)


=========================================

HTTP 상태코드
2xx ~ok

3xx ~ redirection 추가조치필요(경로 돌려버리기)
301,308 경로가 바뀜(301은 메시지바디 존재 될 수 있음, 308은 메시지바디 없음) =>308 잘 안씀
302,303,307 => 일시적으로 경로바뀜(302는 메서드가get으로 변할 수 있고 본문이 제거 될 수 있음, 307 메서드와 본문 유지, 303 메서드가 get으로 변경)
=>302써도 큰 문제는 없다.
304 => 리소스가 수정되지 않음을 알림, 클라이언트는 로컬캐시로 리다이렉트 (메시지바디를 포함하면안된다, 클라는 로컬캐시를 사용해야하니)
PRG => Post Redirect Get 주문에대한 응답응 상품주문완료화면으로 반환

4xx 클라이언트가 오류를 냄
401 인증필요=>누구인지 확인필요 (권한까지 필요한 인가아님)
403 승인거부
404 리소스 없음 or 권한부족리소스를 접근에 대해 숨길때

5xx 서버가 오류를냄
500 서버내부문제임
503 서버과부하 또는 서버다운

=========================================

Header
Http 전송에 필요한 모든 부가정보
표현헤더(표현데이터 해석할 수 있는 정보 제공) + 표현데이터(실제 데이터 =>페이로드라고도함)로 데이터 전달

표현에는 (데이터 형식, 압축방식, 언어가 표현되어있다)
content type , content encoding, content lannguage, content length 가 존재.

Header의 일반정보

요청시 표현
referer : 이전 웹페이지 주소, User-agent: 클라이언트의 어플리케이션정보 (어떤 브라우저에서 장애가 있는지 확인가능)
응답시 사용
Server, Date : 요청처리하는 원서버, 메시지 날짜 시간

특별한 정보

Host: 요청시 사용, 필수, 하나의 서버가 여러 도메인을 처리할때 구분을
Location: 응답결과로 Location 위치로 이


협상(accept~)

클라이언트가 선호하는 표현에 따라 표현의 미디어타입, 문자인코딩방식, 압축방식, 언어 우선순위 조정


전송방식

단순전송, 압축전송(압축방식 헤더 기입필요), 분할전송(transfer encoding : chunked) =>contentlength는 기입하지 않음


쿠키
모든 요청에 쿠키정보 자동 포함
>트래픽 추가유발함, 최소한의 정보만 사용한다.
>쿠키나 웹스토리지에 민감한정보는 기입해선안된다.

사용처 : 사용자 로그인 세션관리, 광고정보트래킹

==============================
Header2 - 캐시와 조건부 요청

캐시를 통해 네트워크를 통한 데이터다운로드를 일정시간 없애는게 가능. UX향상.
시간초과로 재요청을 해서,
검증헤더를 통해 마지막수정시간을 확인하여 마지막 수정시간이 바뀌면 다시 데이터를 받는
만약 수정시간이 같다면 message body 없이 응답, 데이터 요청을 빠르게 처리가능.

ETag(Entity Tag)
서버에서 데이터에 버전을 표기

cache-control =>
cache-control: max age 유효시간
cache-control: no-cache 데이터는 캐시해도되지만 항상 원서버에 검증 후 사용
cache-cnotrol: no-store 데이터에 민감한 정보가 있으므로 저장하면안됨.

proxy cache(public cache)
원서버에서 데이터를 받아 클라이언트에게 전달 데이터 전송 속도의 대폭향(클라이언트는 기본적으로 private cache)

고객잔고등 민감한 정보는 캐시되면안 이런경우, no-cache, no-store, must-revalidate를 기입함.