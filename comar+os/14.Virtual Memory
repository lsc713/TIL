스왑 - 메모리에서 안쓰는 프로세스 보조기억장치일부에 적재하고 그 자리를 다른 프로세스 적재
스왑인 - 메모리로 옮김, 스왑아웃 - 메모리에서 보조기억장치로 옮겨짐

=========
메모리 할당방식
1.최초적합 - 운영체제가 메모리에 들어갈 수 있는 공간 찾으면 바로 들감
2.최적적 - 운영체제가 빈공간을 모두 탐색해서 가장 최적의 공간에 배치하는 방식
3.최악적합 - 운영체제가 빈공간중 프로세스가 적재가능한 공간중 가장 큰 공간에 프로세스 배치
===========

외부단편화- 연속적으로 메모리에 할당되는 환경인 경우 실제 메모리상 공간은 있는데 메모리가 나뉘어져 있어서 프로세스가 적재안되는 현상
압축(메모리조각모음)을 통해 메모리의 프로세스를 재배치하여 빈공간을 하나의 큰공간으로 만듬
->요샌 잘 안쓰고 페이징기법씀

내부단편화- 프로세스가 필요한 양보다 더 큰 메모리를 할당한 경우

=====================

Paging

메모리(프레임)와 프로세스(페이지)를 일정 크기로 잘라서 불연속적으로 프로세스를 적재.
프로세스의 논리 주소공간을 페이지라고하며, 메모리의 물리주소공간을 프레임이라고함.

페이지테이블 - 페이지번호와 프레임번호를 짝지음

이런 불연속성을 cpu입장에서 없애기 위해
각 프로세스는 프로세스테이블이 존재하며 cpu는 Page Table Base Register (PTBR)이 존재하여
각프로세스의 페이지테이블의 적재주소를 알 수 있다.
->페이지테이블을 메모리에 두면 효율상 문제가 있어서 CPU곁에
MMU내에 TLB(Translation Lookaside Buffer)라는
페이지테이블 캐시메모리를 두어 참조지역성의 원리에 따라 페이지테이블의 일부를 조장.

===============

페이지 테이블내의 각 행을 페이지테이블엔트리라고하며
페이지번호와 프레임번호외에 하기의 정보가 추가적으로 들어있다
1.유효비트 - 해당페이지에 접근이 가능한가(메모리에 적재되어있는가)
2.보호비트 - 읽기,쓰기,실행이 가능한지 알 수있다.(r w x(eXecute)
3.참조비트 - 최근 cpu가 접근한적이 있는가.
4.수정비트 - 해당페이지에 데이터수정여부(dirty bit)

=============
쓰기시 복사

프로세스 fork시 부모프로세스를 복제하여 모든자원이 메모리에 복제되는 경우도 있지만
쓰기시 복사시에는 자식프로세스의 페이지테이블의 프레임번호가 부모프로세스의 페이지테이블의 프레임번호와 완전히 동일하며
쓰기시에만 그 일부 페이지엔트리에대해서만 새로운 프레임을 할당하는 것.
->프로세스 생성시간을 줄이고 메모리공간을 절약한다.

============

계층적 페이징

요새 프로세스는 넘큼. 프로세스테이블도 그럼 커짐. 이에 대안으로서 페이지테이블을 계층화하여
페이지테이블을 위한 페이지테이블(outer페이지테이블)을 도하여 모든 페이지테이블을 메모리에 두는 것이아니라 일부는 메모리영역에
나머지는 보조기억장치에 적재.


=========================================

14-3페이지 교체와 프레임 할당

요구페이징 - 페이지가 필요할때 메모리에 적재하는기법
FIFO - 순서대로 교체
최적 페이지교체알고리즘 - cpu가 앞으로 사용빈도에 따라 사용빈도가 낮을 페이지를 교체하는 알고리(이론상의 존재하며 타 알고리즘의 성능평가를 위한 목적)
LRU Least Recently Used 페이지 교체알고리

스래싱 - 실제 프로세스실행시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제
->프레임할당을 그럼 어떻게 해야할까
1.균등할당 (비권장)
2.비례할당 - 프로세스 크기에 따라
-==========하기의 방식은 프로세스의 실행을 보고 프레임수를 할당할지 결정하기때문에 동적할당방식에 해당한다.
3.작업집합모델 - 참조지역성의 원리에 따라 일정시간동안 참조한 '작업집합'만큼의 프레임을 할당.
4.페이지폴트빈도 - 페이지폴트율에 따라 페이지폴트율이 적당할만큼 프레임을 할당.